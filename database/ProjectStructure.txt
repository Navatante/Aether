com.yourapp
├── application/
│   ├── coordinator/
│   │   ├── MainCoordinator.java
│   │   └── FlightCoordinator.java
│   └── di/
│       ├── AppComponent.java
│       ├── DatabaseModule.java
│       ├── RepositoryModule.java
│       ├── UseCaseModule.java
│       └── ViewModelModule.java
│
├── presentation/
│   ├── viewmodel/
│   │   ├── base/
│   │   │   └── BaseViewModel.java
│   │   ├── FlightListViewModel.java
│   │   └── PersonListViewModel.java
│   └── view/
│       ├── controller/
│       │   ├── FlightListController.java
│       │   └── PersonListController.java
│       └── fxml/
│           ├── flight_list.fxml
│           └── person_list.fxml
│
├── domain/
│   ├── interactor/
│   │   ├── GetFlightsInteractor.java
│   │   ├── GetPersonsInteractor.java
│   ├── repository/contract/
│   │   ├── FlightRepository.java
│   │   ├── PersonRepository.java
│
└── data/
    ├── database/
    │   ├── Database.java
    │   ├── FlightDAO.java
    │   └── PersonDAO.java
    ├── model/
    │   ├── Flight.java
    │   └── Person.java
    ├── repository/
    │   ├── FlightRepositoryImpl.java
    │   ├── PersonRepositoryImpl.java



📌 Explicación de la Arquitectura
Esta estructura sigue MVVM-C (Model-View-ViewModel-Coordinator) junto con DAO (Data Access Object) y Clean Architecture.

Cada carpeta tiene una responsabilidad clara, lo que facilita la escalabilidad, el mantenimiento y la separación de lógica.

com.yourapp
├── application/       # Configuración global, navegación y DI
│   ├── coordinator/   # Manejo de navegación entre pantallas
│   └── di/            # Inyección de dependencias con Dagger 2
│
├── presentation/      # Capa de UI (interfaz de usuario)
│   ├── viewmodel/     # Lógica de presentación, maneja la UI
│   └── view/          # Pantallas y controladores JavaFX
│
├── domain/            # Reglas de negocio y contratos
│   ├── interactor/    # Casos de uso (lógica de negocio)
│   └── repository/    # Interfaces de los repositorios
│
└── data/              # Acceso a datos (DB, API, Repositorios)
    ├── database/      # Configuración de la base de datos y DAOs
    ├── model/         # Modelos de datos (Entidades)
    ├── repository/    # Implementaciones de los repositorios

1️⃣ application/ → Configuración Global
Esta carpeta maneja la configuración principal de la app, como la navegación y la inyección de dependencias.

📌 Subcarpetas

coordinator/ → Controla la navegación entre pantallas.
di/ → Configura Dagger 2 para la inyección de dependencias.

✅ coordinator/ → Manejo de Navegación
El Coordinator se encarga de manejar las transiciones entre pantallas. Así, los controladores (Controller) no tienen que preocuparse por la navegación, lo que mejora la organización del código.

📌 Ejemplo: MainCoordinator.java

public class MainCoordinator {
    private final Stage primaryStage;

    public MainCoordinator(Stage primaryStage) {
        this.primaryStage = primaryStage;
    }

    public void showFlightList() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource("/presentation/view/fxml/flight_list.fxml"));
        Parent root = loader.load();
        primaryStage.setScene(new Scene(root));
        primaryStage.show();
    }
}

✅ Beneficio: Centraliza la navegación, evitando que cada Controller tenga que manejar cambios de pantalla.

✅ di/ → Inyección de Dependencias con Dagger 2

📌 Ejemplo de AppComponent.java (Dagger 2)

@Component(modules = {DatabaseModule.class, RepositoryModule.class, UseCaseModule.class})
public interface AppComponent {
    FlightRepository getFlightRepository();
    GetFlightsInteractor getFlightsInteractor();
}

✅ Beneficio: Facilita la inyección de dependencias, evitando la creación manual de objetos.

2️⃣ presentation/ → Capa de UI (JavaFX)
Aquí se manejan la interfaz gráfica y la lógica de presentación.

📌 Subcarpetas

viewmodel/ → Contiene los ViewModels, que procesan la lógica de UI.
view/ → Contiene los FXML y sus respectivos Controladores (Controllers).

✅ viewmodel/ → Lógica de Presentación
Los ViewModels manejan la lógica de la UI, interactuando con los Interactors para obtener datos.

📌 Ejemplo: FlightListViewModel.java

public class FlightListViewModel {
    private final GetFlightsInteractor getFlightsInteractor;
    private final ObservableList<Flight> flights = FXCollections.observableArrayList();

    public FlightListViewModel(GetFlightsInteractor getFlightsInteractor) {
        this.getFlightsInteractor = getFlightsInteractor;
    }

    public void loadFlights() {
        List<Flight> flightList = getFlightsInteractor.execute();
        flights.setAll(flightList);  // Actualiza la UI con los datos obtenidos
    }

    public ObservableList<Flight> getFlights() {
        return flights;
    }
}

✅ Beneficio: Separa la lógica de presentación del Controller, haciendo que el código sea más limpio.

✅ view/ → Pantallas y Controladores

📌 Ejemplo: FlightListController.java

public class FlightListController {
    @FXML private TableView<Flight> flightTable;

    private final FlightListViewModel flightListViewModel;

    public FlightListController(FlightListViewModel flightListViewModel) {
        this.flightListViewModel = flightListViewModel;
    }

    @FXML
    public void initialize() {
        flightTable.setItems(flightListViewModel.getFlights());
        flightListViewModel.loadFlights();
    }
}

✅ Beneficio: Evita mezclar lógica de negocio con la UI, mejorando la mantenibilidad.

3️⃣ domain/ → Lógica de Negocio
Aquí se define la lógica de negocio pura, sin depender de la UI ni de la base de datos.

📌 Subcarpetas

interactor/ → Contiene los Casos de Uso (reglas de negocio).
repository/contract/ → Define interfaces de los repositorios.

✅ interactor/ → Casos de Uso

Los Casos de Uso (Use Cases) encapsulan reglas de negocio.

📌 Ejemplo: GetFlightsInteractor.java

public class GetFlightsInteractor {
    private final FlightRepository flightRepository;

    public GetFlightsInteractor(FlightRepository flightRepository) {
        this.flightRepository = flightRepository;
    }

    public List<Flight> execute() {
        return flightRepository.getAllFlights();
    }
}

✅ Beneficio: Permite reutilizar lógica de negocio sin depender de la UI o la base de datos.

✅ repository/contract/ → Interfaces de Repositorios

📌 Ejemplo: FlightRepository.java (Interface)

public interface FlightRepository {
    List<Flight> getAllFlights();
}
✅ Beneficio: Define un contrato independiente de la implementación de datos.

4️⃣ data/ → Capa de Datos (Base de datos, Modelos, Repositorios)
Aquí se maneja el acceso a los datos y su almacenamiento.

📌 Subcarpetas

database/ → Configuración de SQLite y DAOs.
model/ → Modelos de datos (Entidades).
repository/ → Implementaciones de los repositorios.
✅ database/ → Configuración de SQLite

📌 Ejemplo: FlightDAO.java

public interface FlightDAO {
    @Query("SELECT * FROM flights")
    List<Flight> getAllFlights();
}
✅ Beneficio: Encapsula las consultas SQL en interfaces DAO.

✅ model/ → Entidades de Datos

📌 Ejemplo: Flight.java

public class Flight {
    private int id;
    private String destination;
    private String departureTime;
}
✅ Beneficio: Separa los modelos de la lógica de negocio.

✅ repository/ → Implementaciones de Repositorios

📌 Ejemplo: FlightRepositoryImpl.java

public class FlightRepositoryImpl implements FlightRepository {
    private final FlightDAO flightDAO;

    public FlightRepositoryImpl(FlightDAO flightDAO) {
        this.flightDAO = flightDAO;
    }

    @Override
    public List<Flight> getAllFlights() {
        return flightDAO.getAllFlights();
    }
}
✅ Beneficio: Separa la lógica de negocio del acceso a datos.

📌 Conclusión
🔹 Esta estructura modular mejora la escalabilidad y mantenimiento.
🔹 Separa correctamente la lógica de UI, negocio y datos.
🔹 Usa Coordinators para navegación y Dagger 2 para inyección de dependencias.

¡Con esto puedes desarrollar la app de manera clara y escalable! 🚀


"Aether" es un nombre interesante y evocador. Hace referencia al "éter", que en la mitología griega era el dios del cielo superior y,
en la ciencia antigua, se consideraba el quinto elemento o la sustancia que llenaba el espacio. Para una aplicación que gestiona vuelos,
puede dar la sensación de algo etéreo, ligero y relacionado con el cielo, lo cual encaja bastante bien.

Recomendación:
Confiar en SQLite para manejar la concurrencia
Seguir usando CompletableFuture para operaciones asíncronas


UnitOfWork: Maneja transacciones
DatabaseConnection: Gestiona conexiones a la base de datos
PersonDAO: Acceso a datos
PersonRepositoryImpl: Implementa el contrato del repositorio
Person: Modelo de dominio
PersonEntity: Modelo de datos
PersonMapper/PersonUiMapper: Mapean entre las diferentes capas
PersonViewController/ViewModel/View: Implementan el patrón MVVM

Cuando usas journal_mode = DELETE en SQLite (el modo predeterminado), la forma en que se maneja la concurrencia es un poco diferente al modo WAL. Aquí te explico cómo funciona:
________________________________________
•	📌 Principales Características de journal_mode = DELETE
1.	Modo de journaling tradicional:
o	En este modo, SQLite utiliza un archivo de diario (journal) que mantiene un registro de todas las operaciones realizadas, para que pueda revertir cambios si la transacción falla o el sistema se cae.
o	El archivo mi_db.db-journal se crea para registrar las transacciones, y se elimina cuando se finaliza correctamente la transacción.
2.	Lecturas concurrentes:
o	Sí, en DELETE, las lecturas concurrentes son posibles.
o	Las lecturas no bloquean el acceso de otras conexiones a la base de datos, siempre que no estén realizando una escritura en ese momento. Es decir, puedes hacer varias lecturas simultáneas sin problemas.
3.	Bloqueo de archivo durante escrituras:
o	El archivo de la base de datos solo se bloquea cuando hay una escritura (INSERT, UPDATE, DELETE).
o	Lecturas no causan bloqueo en la base de datos, pero si ocurre una escritura, se bloquean las escrituras concurrentes (no las lecturas).
4.	Manejo de escrituras concurrentes:
o	Si varias conexiones intentan escribir en la base de datos al mismo tiempo, SQLite utiliza un sistema de bloqueos de archivos para garantizar que solo una escritura se realice a la vez.
o	Cuando una escritura está en curso, las otras conexiones que intenten realizar una escritura se bloquean temporalmente y deben esperar a que termine la transacción de escritura.
o	El bloqueo de escritura en este modo es por transacción. Una vez que la transacción se completa, el archivo se desbloquea y otra escritura puede comenzar.
5.	¿Qué pasa si coinciden lecturas y escrituras?
o	Si una lectura ocurre mientras se está realizando una escritura, la lectura puede proceder sin ningún problema.
o	Si ocurre una escritura concurrente, las lecturas continuarán, pero las escrituras se bloquearán temporalmente hasta que se libere el bloqueo.
o	No hay un timeout explícito para las lecturas. Las lecturas pueden acceder a la base de datos de manera continua, pero si hay una escritura, las otras escrituras deben esperar a que termine


Para determinar qué campos necesitan ser JavaFX Properties y cuáles pueden ser campos regulares, debemos analizar cómo se usa cada campo en la interfaz de usuario. Aquí te explico los criterios:
NECESITAN ser Properties:

Campos que se muestran en celdas editables de TableView/ListView
Campos que se usan en bindings bidireccionales (por ejemplo, con TextFields)
Campos que necesitan notificar cambios a otros componentes
Campos que se usan en filtros dinámicos o propiedades computadas

NO NECESITAN ser Properties:

Campos que son solo de lectura en la UI
Campos que solo se muestran pero no se editan
Campos que no participan en bindings
Identificadores (como ID) que no cambian

Por ejemplo, en tu caso:
javaCopypublic static class PersonUI {
    // No necesitan ser Properties:
    private Integer id;                  // Solo identificador, no cambia
    private String dni;                  // Normalmente solo lectura
    private Long antiguedadEmpleo;       // Calculado/solo lectura
    private Long fechaEmbarque;          // Fecha fija, solo lectura

    // Sí necesitan ser Properties:
    private StringProperty name;         // Editable en la UI
    private StringProperty phone;        // Editable en la UI
    private StringProperty active;       // Participa en filtros
    private StringProperty role;         // Puede cambiar y afectar otros componentes

    // Ejemplo de implementación lazy para 'name':
    private String nameValue;            // Backing field
    private StringProperty nameProp;     // Lazy property

    public String getName() {
        return nameValue;
    }

    public void setName(String value) {
        nameValue = value;
        if (nameProp != null) {
            nameProp.set(value);
        }
    }

    public StringProperty nameProperty() {
        if (nameProp == null) {
            nameProp = new SimpleStringProperty(nameValue);
        }
        return nameProp;
    }
}

Un enfoque práctico es:

Comenzar con todos los campos como valores regulares
Convertir a Properties solo cuando encuentres un caso de uso específico que lo requiera
Implementar la inicialización lazy para esas Properties
Documentar por qué cada campo es una Property para futuro mantenimiento

Esto te ayudará a tener un mejor rendimiento mientras mantienes la funcionalidad necesaria.